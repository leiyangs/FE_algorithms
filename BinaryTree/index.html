<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>什么是树结构 | 前端算法</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="https://vuejs.org/images/logo.png">
    <meta name="description" content="前端算法">
    
    <link rel="preload" href="/FE_algorithms/assets/css/0.styles.75bd0095.css" as="style"><link rel="preload" href="/FE_algorithms/assets/js/app.ea110cb0.js" as="script"><link rel="preload" href="/FE_algorithms/assets/js/2.3a1339b0.js" as="script"><link rel="preload" href="/FE_algorithms/assets/js/8.bc4903b6.js" as="script"><link rel="prefetch" href="/FE_algorithms/assets/js/10.952f1b3c.js"><link rel="prefetch" href="/FE_algorithms/assets/js/11.8fdb8589.js"><link rel="prefetch" href="/FE_algorithms/assets/js/12.26cca9b4.js"><link rel="prefetch" href="/FE_algorithms/assets/js/13.4f44b26b.js"><link rel="prefetch" href="/FE_algorithms/assets/js/14.0215387f.js"><link rel="prefetch" href="/FE_algorithms/assets/js/15.db0414d5.js"><link rel="prefetch" href="/FE_algorithms/assets/js/16.e33101f8.js"><link rel="prefetch" href="/FE_algorithms/assets/js/17.aeff203e.js"><link rel="prefetch" href="/FE_algorithms/assets/js/18.ee437b9b.js"><link rel="prefetch" href="/FE_algorithms/assets/js/19.16ddaf29.js"><link rel="prefetch" href="/FE_algorithms/assets/js/20.e2c47455.js"><link rel="prefetch" href="/FE_algorithms/assets/js/3.2b97a456.js"><link rel="prefetch" href="/FE_algorithms/assets/js/4.b336ed77.js"><link rel="prefetch" href="/FE_algorithms/assets/js/5.5c4174ee.js"><link rel="prefetch" href="/FE_algorithms/assets/js/6.e8ee2075.js"><link rel="prefetch" href="/FE_algorithms/assets/js/7.a6004d9b.js"><link rel="prefetch" href="/FE_algorithms/assets/js/9.0a9f24b8.js">
    <link rel="stylesheet" href="/FE_algorithms/assets/css/0.styles.75bd0095.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/FE_algorithms/" class="home-link router-link-active"><img src="https://vuejs.org/images/logo.png" alt="前端算法" class="logo"> <span class="site-name can-hide">前端算法</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/FE_algorithms/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/FE_algorithms/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/leiyangs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/FE_algorithms/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/FE_algorithms/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/leiyangs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>链表</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>队列</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>栈</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>二叉树</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/FE_algorithms/BinaryTree/" aria-current="page" class="active sidebar-link">什么是二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_1-二叉树" class="sidebar-link">1. 二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_1-1-二叉树的定义" class="sidebar-link">1.1 二叉树的定义</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_1-2-二叉树的性质" class="sidebar-link">1.2 二叉树的性质</a></li></ul></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_2-二叉树的遍历" class="sidebar-link">2. 二叉树的遍历</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_3-操作" class="sidebar-link">3. 操作</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_4-二叉树分类" class="sidebar-link">4. 二叉树分类</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_5-树结构的理解" class="sidebar-link">5. 树结构的理解</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_6-完全二叉树" class="sidebar-link">6. 完全二叉树</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_7-二叉树的作用" class="sidebar-link">7. 二叉树的作用</a></li><li class="sidebar-sub-header"><a href="/FE_algorithms/BinaryTree/#_8-算法题" class="sidebar-link">8. 算法题</a></li></ul></li><li><a href="/FE_algorithms/BinaryTree/LeetCode/" class="sidebar-link">力扣</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>堆</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并查集</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="什么是树结构"><a href="#什么是树结构" class="header-anchor">#</a> 什么是树结构</h1> <p>定义</p> <ul><li><p>一棵树（tree）是由 n（n&gt;0）个元素组成的有限集合，其中：</p> <ul><li>每个元素称为结点（node）； -有一个特定的结点，称为根结点或根（root）；</li> <li>除根结点外，其余结点被分成 m（m&gt;=0）个互不相交的有限集合，而每个子集又都是一棵树（称为原树的子树）</li></ul></li></ul> <p>概念</p> <ul><li><p>度</p> <ul><li>树的度——也即是宽度，简单地说，就是结点的分支数。以组成该树各结点中最大的度作为该树的度，树中度为零的结点称为叶结点或终端结点。树中度不为零的结点称为分枝结点或非终端结点。除根结点外的分枝结点统称为内部结点。</li></ul></li> <li><p>深度</p> <ul><li>树的深度——组成该树各结点的最大层次；</li></ul></li> <li><p>层次</p> <ul><li>根结点的层次为 1，其他结点的层次等于它的父结点的层次数加 1</li></ul></li> <li><p>路径</p> <ul><li>对于一棵子树中的任意两个不同的结点，如果从一个结点出发，按层次自上而下沿着一个个树枝能到达另一结点，称它们之间存在着一条路径。可用路径所经过的结点序列表示路径，路径的长度等于路径上的结点个数减 1</li></ul></li> <li><p>森林</p> <ul><li>指若干棵互不相交的树的集合</li></ul></li></ul> <h2 id="_1-二叉树"><a href="#_1-二叉树" class="header-anchor">#</a> 1. 二叉树</h2> <ul><li><p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分 。</p></li> <li><p>二叉树是 n 个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个结点。</p></li> <li><p>二叉树（binary tree）是指树中节点的度不大于 2 的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 链表到树的差异</span>
<span class="token comment">// 1. 链表</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2. 三叉树</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">[</span>TreeNode<span class="token punctuation">,</span> TreeNode<span class="token punctuation">,</span> TreeNode<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// next指向下一个树的节点</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-1-二叉树的定义"><a href="#_1-1-二叉树的定义" class="header-anchor">#</a> 1.1 二叉树的定义</h3> <ul><li><p>非空二叉树只有一个根结点；</p></li> <li><p>每一个结点最多有两棵子树，且分别称为该结点的左子树和右子树。即时树中只有一棵子树，也要区分是左子树还是右子树。</p></li></ul> <h3 id="_1-2-二叉树的性质"><a href="#_1-2-二叉树的性质" class="header-anchor">#</a> 1.2 二叉树的性质</h3> <ul><li><p>在二叉树的第 n 层上，最多有 2ⁿ﹣¹（n≥1）个结点</p> <ul><li>2^0 + 2^1 + 2^2 ...</li></ul></li> <li><p>深度为 n 的二叉树最多有 2ⁿ-1 个结点</p></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">2</span><span class="token operator">^</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">...</span>
<span class="token function">a1</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">-</span> q<span class="token operator">^</span>k <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> q<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token operator">^</span>k<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token operator">^</span>k <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span>k <span class="token operator">-</span> <span class="token number">1</span>
</code></pre></div><ul><li><p>在任意一棵二叉树中，度为 0 的结点（即叶子结点）总是比度为 2 的结点多一个</p> <ul><li>总节点数 = 总边数 + 1</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 度为0的节点 + 度为2的节点 = 0个节点 + 1个节点 + 2*2个节点 + 1</span>
n0 <span class="token operator">+</span> n1 <span class="token operator">+</span> n2 <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> n1 <span class="token operator">+</span> <span class="token number">2</span>n2 <span class="token operator">+</span> <span class="token number">1</span>
n0 <span class="token operator">=</span> n2 <span class="token operator">+</span> <span class="token number">1</span>
</code></pre></div><ul><li>具有 n 个结点的二叉树，其深度至少为［log2n］+1，其中［log2n］表示取 log2n 的整数部分</li></ul> <h2 id="_2-二叉树的遍历"><a href="#_2-二叉树的遍历" class="header-anchor">#</a> 2. 二叉树的遍历</h2> <p>有三种重要的遍历方式</p> <ul><li><p>前序：根 左 右</p></li> <li><p>中序：左 根 右</p></li> <li><p>后序：左 右 根</p></li></ul> <h2 id="_3-操作"><a href="#_3-操作" class="header-anchor">#</a> 3. 操作</h2> <p>根据 中序 + 前/后 遍历结果，还原二叉树。(只需要找出每棵树的根节点即可，前序遍历的第一个肯定是根节点)</p> <p>练习：</p> <p>​ 请根据遍历结果，画出二叉树</p> <p>​ 前： 1 2 4 9 5 6 10 3 7 8​ 中: 4 9 2 10 6 5 1 3 8 7</p> <ul><li><p>思路</p> <p><img src="/FE_algorithms/assets/img/binaryTreeUntitled.8a861b8e.png" alt="binaryTree"></p></li> <li><p>结果</p> <p><img src="/FE_algorithms/assets/img/BinaryTree.86daf787.png" alt="binaryTree"></p></li></ul> <h2 id="_4-二叉树分类"><a href="#_4-二叉树分类" class="header-anchor">#</a> 4. 二叉树分类</h2> <ul><li><p>完全二叉树 (complete binary tree)</p> <ul><li>有且只有最后一层不是满的。</li> <li>最后一层的结点是从左开始排列的，也就是说右子树的右子节点可以少。</li></ul></li> <li><p>满二叉树 (full binary tree)</p> <ul><li>所有结点的度都是 0 或 2 的二叉树。</li></ul></li> <li><p>完美二叉树 (perfect binary tree)</p> <ul><li>二叉树上每一层的结点数都达到了最大。看上去就像上个三角形。</li></ul></li></ul> <p>几种二叉树的定义在不同的资料说明中可能存在一定差异，因此在实际场合中提到时请务必进行确认。</p> <h2 id="_5-树结构的理解"><a href="#_5-树结构的理解" class="header-anchor">#</a> 5. 树结构的理解</h2> <ul><li>节点： 代表集合。 边： 代表关系</li></ul> <h2 id="_6-完全二叉树"><a href="#_6-完全二叉树" class="header-anchor">#</a> 6. 完全二叉树</h2> <p>节省存储边的空间(next)，用数组记录即可，但是会浪费时间。</p> <ul><li>编号为 i 的子节点
<ul><li>左孩子编号为 2 * i</li> <li>右孩子编号为 2 * i + 1</li></ul></li></ul> <h2 id="_7-二叉树的作用"><a href="#_7-二叉树的作用" class="header-anchor">#</a> 7. 二叉树的作用</h2> <ul><li><p>AVL 树： 标准语言库中重要的数据检索底层实现</p> <p>​ B+ / B- 树： 文件系统、数据库底层重要数据结构</p></li> <li><p>左孩子右兄弟 - 节省空间</p> <ul><li>三叉树转二叉树，按找左孩子右兄弟的方式</li></ul> <p>​ 假设有 n 个节点, 浪费的边数：</p> <p>​ 有效的边数：n - 1 个（根节点不需要边指向）</p> <p>​ 浪费的指针域：</p> <p>​ k 叉树： k * n - ( n - 1) =&gt; (k - 1) * n + 1</p> <p>​ 2 叉树：2 * n - (n - 1) =&gt; n + 1</p> <p>​ 得出，叉越多，浪费的指针域越多。</p></li> <li><p>练习递归的最佳选择</p> <ul><li>数学归纳法</li> <li>赋予一个明确的含义</li> <li>思考边界条件</li> <li>实现递归</li></ul></li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 斐波那契数列，前两个数固定，后面的值是前两位的和</span>
<span class="token comment">// 1,2,3,5,8,13,21</span>
<span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_8-算法题"><a href="#_8-算法题" class="header-anchor">#</a> 8. 算法题</h2> <ul><li>144.二叉树的前序遍历</li></ul> <p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">getNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">getNode</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>105.从前序与中序遍历序列构造⼆叉树</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">buildNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">buildNode</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 构建根节点</span>
  <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前序遍历第一个是根</span>

  <span class="token comment">// 找到根节点在中序遍历中的位置</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">!==</span> inorder<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 中序遍历左子树</span>
  <span class="token keyword">let</span> inorderLeft <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 中序遍历右子树</span>
  <span class="token keyword">let</span> inorderRight <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 前序遍历左子树</span>
  <span class="token keyword">let</span> preorderLeft <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 前序遍历右子树</span>
  <span class="token keyword">let</span> preorderRight <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildNode</span><span class="token punctuation">(</span>preorderLeft<span class="token punctuation">,</span> inorderLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildNode</span><span class="token punctuation">(</span>preorderRight<span class="token punctuation">,</span> inorderRight<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/FE_algorithms/Stack/LeetCode/" class="prev">
        力扣
      </a></span> <span class="next"><a href="/FE_algorithms/BinaryTree/LeetCode/">
        力扣
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/FE_algorithms/assets/js/app.ea110cb0.js" defer></script><script src="/FE_algorithms/assets/js/2.3a1339b0.js" defer></script><script src="/FE_algorithms/assets/js/8.bc4903b6.js" defer></script>
  </body>
</html>
